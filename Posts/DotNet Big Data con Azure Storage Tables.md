---
title: .NET - Guardando datos con Azure Storage Tables
published: true
publishDate: 10/10/2022
description: En este art√≠culo veremos qu√© es y c√≥mo usar la API de Tables Storage de Azure.
tags: ["dotnet","azure","aspnetcore", "csharp"]
---

## ¬øQu√© es Azure Storage Table?
Azure Storage Tables es un servicio de persistencia que maneja informaci√≥n no-relacional estructurada en la nube. Ofreciendo un mecanismo de almacenamiento key/attributes (Tablas y Rows) sin un esquema forzado (como T-SQL).

Storage Tables es un servicio de bajo costo y eficiente, que permite guardar **terabytes** de informaci√≥n.  Al no forzar el uso de un esquema como en SQL Server (o cualquier base de datos relacional) la adopci√≥n y la evoluci√≥n es r√°pida y sencilla.

Table storage no es necesariamente para usarse como tu persistencia principal, yo lo veo como algo complementario a una base de datos principal. Suele guardarse informaci√≥n en grandes cantidades y de forma estructurada para que pueda consultarse de forma eficiente.

El uso que se le puede dar es el que desees, solo debes de considerar que no est√° pensado para que sea una base de datos relacional, sino para guardar informaci√≥n como:

- Terabytes de informaci√≥n estructurada que no requieren relaciones complejas o llaves for√°neas y puede ser desnormalizada para facilitar el acceso y sea m√°s r√°pido.
- Ejemplos:
  - Logs de actividad
    - Tengo sistemas en donde se guarda toda la actividad de los usuarios, y aunque sean millones de registros, se pueden consultar
  - Telemetr√≠a
    - Hace tiempo lo implementamos en un proyecto IoT donde proces√°bamos alrededor de 30 millones de mensajes al mes.
  - Registros masivos
    - En este art√≠culo veremos el registro de solicitudes como ejemplo

> Nota üí°: El c√≥digo fuente lo encuentras en mi github [aqu√≠](https://github.com/isaacOjeda/DevToPosts/tree/main/AzureStorageTables)

### Conceptos importantes
- **Accounts:** Necesitamos un Storage Account para acceder a la API de Tables
  - Junto con un Storage Accounts tambi√©n contamos con:
    - **Queues**. Para mensajer√≠a simple, pero con millones de mensajes
      - Ya he escrito de esto [aqu√≠](https://dev.to/isaacojeda/parte-12-azure-functions-background-jobs-42ih)
    - **Blobs**. Almacenamiento archivos / binarios
- **Table:** Es una colecci√≥n de *Entities*. Tables no te obliga a seguir un esquema en cada entity, lo que significa que en una misma tabla puedes contener distintas propiedades (AKA columnas).
- **Entity:** Un Entity es una colecci√≥n de propiedades, exactamente como un row en una base de datos. Un Entity dentro de Azure Storage puede pesar hasta 1MB. En Azure Cosmos DB puede pesar hasta 2MB.
- **Propiedades:** Una propiedad consiste en un nombre-valor. Cada entity puede tener hasta 252 propiedades.
  - Cada entity tambi√©n tiene 3 propiedades por default donde se especifica el **Partition Key**, **Row Key** y el **timestamp**
  - Entities dentro del mismo **PartitionKey** se pueden consultar significativamente m√°s r√°pido
  - El **RowKey** es la llave primaria de cada Entity.

## Gu√≠a para un buen dise√±o
Es importante considerar los requerimientos iniciales al usar Azure Tables, ya que es necesario decidir c√≥mo vamos a guardar la informaci√≥n dependiendo de c√≥mo queremos consultarla de forma eficiente.

### Dise√±o para una lectura eficiente
- **Siempre especificar el PartitionKey y RowKey en los Queries.** Siempre que hagamos queries, es mucho m√°s eficiente si siempre especificamos la partici√≥n y la llave que buscamos.
  - En el ejemplo que veremos m√°s adelante, nos enfocaremos en este punto.
- **Considera duplicar la informaci√≥n.** Table Storage es muy bar√°to que el tama√±o de la persistencia ya no importa, por lo que guardar el mismo _entity_ varias veces para mejorar las consultas (seg√∫n la necesidad de consulta) es algo recomendable.
- **Desnormalizar tu informaci√≥n.** Al igual que lo anterior, el almacenamiento es de bajo costo, desnormalizar tu informaci√≥n es recomendable. Repetir informaci√≥n dentro de un entity para no tener que consultarla con alguna relaci√≥n hace las consultas m√°s r√°pidas
  - Considera aqu√≠ que la informaci√≥n no cambie a cada momento, si s√≠, pi√©nsalo dos veces.

### Dise√±o para una escritura eficiente
- **Evita particiones que se tengan que acceder demasiado**. La creaci√≥n de particiones a partir de un Key hace muy din√°mico como distribuimos la informaci√≥n.
  - Ejem. En Logs yo suelo crear Partition Keys as√≠: **Events{DDMMYYYY}** y as√≠ tendr√© una partici√≥n cada mes.
  - Ejem. Hablando de IoT, guardaba hist√≥ricos en particiones seg√∫n el dispositivo: **Device{ID_DEVICE}_{DDMMYYYY}** y as√≠ genero particiones por dispositivo y por mes (todo depende tambi√©n, como necesito consultar la informaci√≥n)
- **No siempre es necesario una tabla por cada entity.** Ya que no se nos obliga seguir un esquema, podemos guardar distintos tipos de entities en un mismo table, esto para asegurar operaciones at√≥micas cuando guardamos informaci√≥n. Si este no es el caso, separar en distintas tablas es mejor.

### Si quieres saber m√°s
- [Table design patterns](https://learn.microsoft.com/en-us/azure/storage/tables/table-storage-design-patterns)
- [Design for querying](https://learn.microsoft.com/en-us/azure/storage/tables/table-storage-design-for-query)

# Ejemplo pr√°ctico: Registro masivo de solicitud de Vacunas

Estamos casi a finales del 2022 y yo s√© que ya pas√≥ de moda hablar de las vacunas y pandemia, pero este ejemplo se me ocurri√≥, porque es algo que es *ad hoc* para esta tecnolog√≠a.

En M√©xico, la mec√°nica para vacunarnos (y saber cu√°ntos se pensaban vacunar) era registrarse en una p√°gina web utilizando tu n√∫mero √∫nico de registro de poblaci√≥n (llamado CURP). Millones de personas se registraron, y una vez registrado, pod√≠as consultar tu solicitud o si intentabas registrarte nuevamente, ya no pod√≠as.

Lo que vamos a considerar para dise√±ar esta soluci√≥n:
- Solo te puedes registrar una vez, as√≠ que la CURP funciona como la llave primar√≠a (Row Key)
- Para consultar "n" n√∫mero de solicitudes, se necesita el estado y la ciudad (Partition Key)
- Para consultar tu solicitud, se necesita el Estado y la Ciudad y tu CURP (Partition Key y Row Key)
- Campos: Nombre completo, CURP, Estado y Ciudad

La intenci√≥n de construir as√≠ el **Partition Key** es para poder consultar todas las solitudes de una ciudad de forma r√°pida. No es pr√°ctico querer consultar todo el pa√≠s, pero por ciudad, se reduce m√°s el volumen y podemos hacer queries m√°s espec√≠ficos (como filtrar por edad, g√©nero, etc).

## Proyecto API: AzureTableStorage

Antes de comenzar, debemos de asegurarnos que tenemos el emulador (AKA **Azurite**) instalado. Este viene con las herramientas de Azure de Visual Studio, pero por si no lo tienes, visita esta [p√°gina para conocer m√°s](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite?tabs=visual-studio).

Yo en lo personal me gusta usar **Azurite** con **npm** porque solo con un comando lo puedo iniciar.

Una vez con Azurite instalado, crearemos un proyecto web vac√≠o en una carpeta para el proyecto (en mi caso se llam√≥ **AzureStorageTables**):

```bash
dotnet new web
```

E instalamos los siguientes paquetes:

```bash
dotnet add package Azure.Data.Tables
dotnet add package System.Linq.Async
```

> Nota üí°: Usaremos **System.Linq.Async** para procesar Streams asincronos con Linq.


### Models > VaccineRequest

Definimos nuestro Entity, es necesario implementar la interfaz `ITableEntity`. Aqu√≠ vienen las tres propiedades obligatorias de un Entity en Tables:

```csharp
using Azure;
using Azure.Data.Tables;

namespace AzureStorageTables.Models;

public class VaccineRequest : ITableEntity
{
    public string Curp { get; set; }
    public string FullName { get; set; }
    public string City { get; set; }
    public string State { get; set; }

    public string PartitionKey { get; set; }
    public string RowKey { get; set; }
    public DateTimeOffset? Timestamp { get; set; }
    public ETag ETag { get; set; }
}
```

> Nota üòÇ: `ETag` nunca lo he usado y hasta el d√≠a de hoy no s√© para qu√© es...

### Services > IVaccineRequestStoreService

Aqu√≠ definimos nuestro contrato para nuestro almac√©n de informaci√≥n, _not a big deal_. Por ahora solo tendremos tres m√©todos, uno para crear y dos para consultar:

```csharp
using AzureStorageTables.Models;

namespace AzureStorageTables.Services;

public interface IVaccineRequestStoreService
{
    Task CreateRequestAsync(VaccineRequest entity);
    Task<VaccineRequest> GetRequestAsync(string curp, string state, string city);
    IAsyncEnumerable<VaccineRequest> GetRequestsByCityAsync(string state, string city);
}
```

El Partition Key lo he pensado que est√© compuesto por el Estado y la Ciudad. Por lo que las consultas se deben de hacer siempre especificando estos datos (para que sea super r√°pido).

Si no se especifican el Partition Key en una consulta, esta ser√° muy lenta.

Por lo que, dependiendo de las necesidades, podemos pensar de forma diferente y armar por ejemplo el partition key por solamente el estado, a√±o de nacimiento, sexo, o una combinaci√≥n de todos estos. Siempre recuerda, que deber√°s (aunque no obligado) buscar siempre por partition key.

### Services > VaccineRequestStoreService

Aqu√≠ la implementaci√≥n del **Store**, aqu√≠ es donde utilizamos Tables Storage:

```csharp
using Azure.Data.Tables;
using AzureStorageTables.Models;

namespace AzureStorageTables.Services;

public class VaccineRequestStoreService : IVaccineRequestStoreService
{
    public const string TableName = "VaccineRequests";
    private TableClient _tableClient;

    public VaccineRequestStoreService(IConfiguration config)
    {
        _tableClient = new TableClient(config["TableStorage:ConnectionString"], TableName);
    }

    public async Task CreateRequestAsync(VaccineRequest entity)
    {
        await _tableClient.CreateIfNotExistsAsync();

        entity.PartitionKey = $"{entity.State}_{entity.City}";
        entity.RowKey = entity.Curp;

        _ = await _tableClient.AddEntityAsync(entity);
    }

    public async Task<VaccineRequest> GetRequestAsync(string curp, string state, string city)
    {
        var results = _tableClient
            .QueryAsync<VaccineRequest>(q => q.PartitionKey == $"{state}_{city}" && q.RowKey == curp);

        await foreach (var entity in results)
        {
            return entity;
        }

        return null;
    }


    public IAsyncEnumerable<VaccineRequest> GetRequestsByCityAsync(string state, string city) =>
         _tableClient
            .QueryAsync<VaccineRequest>(q => q.PartitionKey == $"{state}_{city}");

}
```

Resumen de cada m√©todo:
- **CreateRequestAsync**
  - `CreateIfNotExistsAsync` crea la tabla si esta no existe
    - Ten en cuenta que esto es un request HTTP, se podr√≠a buscar la forma de solo hacerlo al inicio y no en cada **Create**
- **GetRequestAsync**: 
  - `QueryAsync` Regresa una colecci√≥n as√≠ncrona (estilo IAsyncEnumerable) de resultados, los debemos de iterar para accesarlos
  - Iteramos con `await foreach` para acceder a los resultados. Lo hacemos de esta forma porque el SDK autom√°ticamente maneja paginaci√≥n
  - En este caso, solo queremos el primer resultado (porque, ser√° un resultado por que usamos el **Row Key**)
  - El Partition Key est√° compuesto por el estado y la ciudad (`$"{state}_{city}"`)
- **GetRequestsByCityAsync**:
  - De igual forma con `QueryAsync` realizamos la consulta, pero aqu√≠ hacemos algo un poco diferente
    - Regresamos un stream de informaci√≥n con `IAsyncEnumerable` para ir procesando la informaci√≥n mientras la vamos consultando
    - Como pueden ser miles de registros, no queremos consultarlos todos en memor√≠a y luego convertirlos en un DTO
    - Regresamos el `AsyncPage` que es una implementaci√≥n de `IAsyncEnumerable` y la presentaci√≥n se encargar√° de convertirlo a DTO con forme vaya llegando la informaci√≥n

### Program.cs

Para terminar, usaremos **Minimal APIs** para crear los endpoints y exponero esta funcionalidad:

```csharp
using Azure;
using AzureStorageTables.Models;
using AzureStorageTables.Services;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddScoped<IVaccineRequestStoreService, VaccineRequestStoreService>();

var app = builder.Build();

// Endpoints Aqu√≠...

app.Run();

```

Para crear y leer solicitudes de vacunaci√≥n, usaremos un DTO para no exponer propiedades que no queremos (como los Partition Key y Etags).

```csharp
namespace AzureStorageTables.Models;

public record VaccineRequestDto(string Curp, string FullName, string City, string State);
```

#### Endpoint POST api/vaccine-requests
Al crear, llamamos directamente al **Store**:

```csharp
app.MapPost("api/vaccine-requests", async (VaccineRequestDto request, IVaccineRequestStoreService store) =>
{
    try
    {
        await store.CreateRequestAsync(new VaccineRequest
        {
            City = request.City,
            State = request.State,
            Curp = request.Curp,
            FullName = request.FullName
        });
    }
    catch (RequestFailedException ex)
        // Ya existe una solicitud con esta CURP
        when (ex.Status == StatusCodes.Status409Conflict)
    {
        return Results.BadRequest($"Ya existe una solicitud del CURP {request.Curp}");
    }

    return Results.Ok();
});
```
Hacemos uso de **Exception Filters** para regresar un `Bad Request` cuando queremos crear una solicitud con **CURP** repetida. Azure nos regresa un `409` si intentamos crear un registro con un Partition Key y Row Key ya existentes.

#### Endpoint GET api/vaccine-requests

Consulta de solicitudes por ciudad:

```csharp
app.MapGet("api/vaccine-requests", (string state, string city, IVaccineRequestStoreService store) =>
{
    return Results.Ok(store
        .GetRequestsByCityAsync(state, city)
        .Select(s => new VaccineRequestDto(s.Curp, s.FullName, s.City, s.State))
    );
});
```

Aqu√≠ estamos aprovechando el `IAsyncEnumerable` para ir procesando y serializando la informaci√≥n al mismo tiempo que se va consultando. De esta forma estamos evitando cargar en memor√≠a todos los datos, sino que los vamos procesando en un Stream de forma as√≠ncrona.

La idea no es regresar miles o millones de registros, la idea es poder consultar unos cientos dentro de miles o millones de registros, pero procesar la informaci√≥n as√≠, es √∫til de igual forma si esto es de alta concurrencia.

#### Endpoint POST api/vaccine-requests/{curp}

Consulta de solicitudes en lo individual:
```csharp
app.MapGet("api/vaccine-requests/{curp}", async(string curp, string state, string city, IVaccineRequestStoreService store) =>
{
    var request = await store.GetRequestAsync(curp, state, city);

    return new VaccineRequestDto(request.Curp, request.FullName, request.State, request.City);
});
```

En teor√≠a, este m√©todo debe de ser muy r√°pido, aunque tengamos millones de registros, esto es porque estamos especificando la partici√≥n y la llave primar√≠a del Entity.

#### appsettings.json

Usamos `UseDevelopmentStorage=true` para que se use Azurite (el emulador local del Storage):

```json
{
  "TableStorage": {
    "ConnectionString": "UseDevelopmentStorage=true"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

### Probando con REST Client
Para probar los endpoints, podemos configurar swagger, pero a veces a m√≠ me gusta hacerlo con solicitudes HTTP manuales (que igual las commiteo) utilizando una extensi√≥n de VS Code llamada [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client).

**Request**
```
### Create Vaccine Request
POST  https://localhost:7066/api/vaccine-requests
Content-Type:  application/json

{
    "fullName": "Isaac Ojeda",
    "curp": "test00001",
    "city": "Chihuahua",
    "state": "Chihuahua"
}
```

**Response**
```
HTTP/1.1 200 OK
Content-Length: 0
Connection: close
Date: Sun, 09 Oct 2022 04:59:38 GMT
Server: Kestrel
```

**Request**
```
### Get Vaccine Requests by State
GET https://localhost:7066/api/vaccine-requests?state=Chihuahua&city=Chihuahua
Content-Type: application/json
```

**Response**
```json
[
  {
    "curp": "1234567890",
    "fullName": "Isaac Ojeda",
    "city": "Chihuahua",
    "state": "Chihuahua"
  },
  {
    "curp": "test00001",
    "fullName": "Isaac Ojeda",
    "city": "Chihuahua",
    "state": "Chihuahua"
  },
  {
    "curp": "test00002",
    "fullName": "Isaac Ojeda",
    "city": "Chihuahua",
    "state": "Chihuahua"
  }
]
```

**Request**
```
### Get Vaccine Request by CURP
GET https://localhost:7066/api/vaccine-requests/test00001?state=Chihuahua&city=Chihuahua
Content-Type: application/json
```

**Response**
```json
{
  "curp": "test00001",
  "fullName": "Isaac Ojeda",
  "city": "Chihuahua",
  "state": "Chihuahua"
}
```

Podemos usar el [Storage Explorer](https://azure.microsoft.com/en-us/products/storage/storage-explorer/#overview) para visualizar la informaci√≥n que vamos creando en el Account.

![Storage Explorer](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/1vjj2cvancsapr2rb8dz.png)

# Conclusi√≥n
Azure Tables Storage lo uso en todos los proyectos en los que participo, ya sea para guardar logs, informaci√≥n de la misma aplicaci√≥n y lo que sea que aplique.

Table Storage puede estar geo-replicado, puede integrarse en una virtual-network de Azure, enlaces privados para nube hibrida y un sin fin de cosas que Azure ofrece.

En lo personal tiene muchos usos, y las cosas se ponen mejores si usamos Azure Cosmos DB. Por lo que te recomiendo que busques m√°s, experimentes y eval√∫a si es una tecnolog√≠a para tu proyecto.

# Referencias
- [Storage overview](https://learn.microsoft.com/en-us/azure/storage/tables/table-storage-overview)
- [Design guidelines](https://learn.microsoft.com/en-us/azure/storage/tables/table-storage-design-guidelines?source=recommendations)
- [Design for query](https://learn.microsoft.com/en-us/azure/storage/tables/table-storage-design-for-query)
- [.NET Client library](https://learn.microsoft.com/en-us/dotnet/api/overview/azure/data.tables-readme)