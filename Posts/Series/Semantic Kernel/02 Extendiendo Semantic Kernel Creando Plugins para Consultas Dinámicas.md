### **1. Introducci√≥n**

En el tutorial [anterior](https://dev.to/isaacojeda/semantic-kernel-crea-un-api-para-generacion-de-texto-con-ollama-y-aspire-686), exploramos c√≥mo configurar y utilizar **Semantic Kernel** junto con **Aspire** y **Ollama** para crear un API b√°sico que generaba res√∫menes de texto. Ahora, vamos a dar un paso m√°s y enfocarnos en una de las caracter√≠sticas m√°s potentes de Semantic Kernel: los **plugins**.

En este tutorial, aprender√°s a crear y utilizar plugins en Semantic Kernel. Los plugins son clases o componentes que encapsulan funciones espec√≠ficas, permitiendo extender las capacidades del kernel con nuevas habilidades personalizadas.

Para ejemplificarlo, desarrollaremos dos plugins:

- Un plugin que retorna la hora actual en formato UTC.
- Un plugin que utiliza datos de geolocalizaci√≥n y clima para proporcionar informaci√≥n meteorol√≥gica de una ciudad espec√≠fica.

Los plugins en Semantic Kernel permiten agregar habilidades modulares y reutilizables. Esto no solo facilita la escalabilidad del proyecto, sino que tambi√©n abre las puertas para integrar servicios externos o l√≥gica personalizada de manera sencilla y eficiente.

> Nota üí°: Aqu√≠ podr√°s encontrar el c√≥digo fuente de este tutorial: [DevToPosts/SemanticKernelSeries/SemanticKernelLearning02 at main ¬∑ isaacOjeda/DevToPosts](https://github.com/isaacOjeda/DevToPosts/tree/main/SemanticKernelSeries/SemanticKernelLearning02)

### **2. Qu√© son los Plugins en Semantic Kernel**

#### **¬øQu√© es un Plugin en Semantic Kernel?**

Un **plugin** en Semantic Kernel es una clase que contiene m√©todos decorados con atributos especiales, como `[KernelFunction]`, para exponer su funcionalidad al kernel. Esto permite que esas funciones sean llamadas por el kernel como si fueran partes integradas de su sistema.

#### **¬øPor qu√© usar Plugins?**

- **Modularidad:** Los plugins encapsulan l√≥gica espec√≠fica, lo que los hace f√°ciles de mantener y reutilizar.
- **Flexibilidad:** Puedes crear plugins para realizar tareas como interactuar con APIs externas, procesar datos o realizar c√°lculos.
- **Integraci√≥n sencilla:** Los plugins se registran f√°cilmente en el kernel, haci√©ndolos disponibles para su uso en el API o dentro de flujos m√°s complejos.

#### **Componentes clave de un Plugin**

1. **M√©todos decorados con `[KernelFunction]`:** Esto marca las funciones que el kernel puede invocar.
2. **Descripci√≥n:** Los m√©todos pueden incluir descripciones para documentar su prop√≥sito, facilitando su descubrimiento.
3. **Dependencias externas:** Los plugins pueden interactuar con servicios externos, como APIs, utilizando patrones conocidos como `IHttpClientFactory`.

#### **Plugins que construiremos en este tutorial**

- **TimeInformationService:** Un plugin que proporciona la hora actual en UTC.
- **WeatherInformationService:** Un plugin que utiliza una API externa para obtener informaci√≥n de geolocalizaci√≥n y clima.

Ambos plugins ser√°n integrados en nuestro kernel y expuestos a trav√©s del API que desarrollamos en el tutorial anterior.

#### **¬øC√≥mo funcionan los Plugins en Semantic Kernel?**

Los plugins registrados en el kernel pueden ser invocados en tiempo de ejecuci√≥n mediante prompts o directamente desde el c√≥digo. El kernel gestiona autom√°ticamente la ejecuci√≥n de estos m√©todos, permitiendo integrarlos en flujos de procesamiento complejos.

### **3. Desarrollo del Ejemplo**

Ahora que entendemos qu√© son los plugins en **Semantic Kernel**, vamos a desarrollar e integrar dos plugins personalizados en nuestro proyecto:

1. **TimeInformationService:** Un plugin simple que devuelve la hora actual en UTC.
2. **WeatherInformationService:** Un plugin m√°s avanzado que utiliza una API externa para obtener informaci√≥n sobre el clima en una ciudad.

#### **Paso 1: Crear los Plugins**

##### **TimeInformationService**

El siguiente plugin proporciona la hora actual en formato UTC. Es un ejemplo sencillo para entender c√≥mo funcionan los plugins b√°sicos en Semantic Kernel.

```csharp
/// <summary>
/// A plugin that returns the current time.
/// </summary>
public class TimeInformationService
{
    [KernelFunction]
    [Description("Retrieves the current time in UTC.")]
    public string GetCurrentUtcTime() => DateTime.UtcNow.ToString("R");
}
```

Aqu√≠ destacamos:

- El atributo `[KernelFunction]` expone el m√©todo al kernel.
- El m√©todo devuelve la hora en formato "R" (RFC1123), que es legible y est√°ndar.

##### **WeatherInformationService**

Este plugin es m√°s complejo. Obtiene informaci√≥n sobre una ciudad (coordenadas, pa√≠s, etc.) y tambi√©n el clima actual utilizando servicios externos.

```csharp
public class WeatherInformationService(IHttpClientFactory httpClientFactory)
{
    [KernelFunction]
    [Description("Get weather information for a city.")]
    public async Task<WeatherInfo> GetWeatherByCity(string cityName)
    {
        if (string.IsNullOrWhiteSpace(cityName))
            throw new ArgumentException("City name cannot be null or empty.", nameof(cityName));

        // Step 1: Get city coordinates
        var city = await GetCityCoordinatesAsync(cityName);

        // Step 2: Get weather data
        var weatherResult = await GetWeatherDataAsync(city.Latitude, city.Longitude);

        return new WeatherInfo
        {
            City = city.Name,
            Country = city.Country,
            Temperature = weatherResult.CurrentWeather.Temperature,
            WindSpeed = weatherResult.CurrentWeather.Windspeed,
            WeatherCode = weatherResult.CurrentWeather.Weathercode
        };
    }

    private async Task<GeocodingResult> GetCityCoordinatesAsync(string cityName)
    {
        // ...For more info, check the source code
    }

    private async Task<WeatherApiResponse> GetWeatherDataAsync(double latitude, double longitude)
    {
        // ...For more info, check the source code
    }
}
```

Puntos clave:

- Este plugin utiliza `IHttpClientFactory` para realizar llamadas HTTP a APIs externas.
	- Como puedes ver, la inyecci√≥n de dependencias funciona sin problema, por lo que aqu√≠ podr√≠amos inyectar lo que se necesite que el plugin realice
- El Kernel utiliza los nombres de los m√©todos y los par√°metros para darles significado y as√≠ usarlo seg√∫n el prompt solicitado.

#### **Paso 2: Registrar los Plugins en el Kernel**

Para que el kernel pueda usar estos plugins, debemos registrarlos en la configuraci√≥n del servicio:

```csharp
var kernel = builder.Services.AddKernel();

// Registrar el servicio de hora
kernel.ImportPlugin<TimeInformationService>();

// Registrar el servicio de clima
kernel.ImportPlugin<WeatherInformationService>();
```

#### **Paso 3: Exponer los Plugins Utilizando el Kernel**

En lugar de llamar directamente a los m√©todos de los servicios, utilizaremos el **Kernel** de Semantic Kernel para invocar los plugins mediante prompts. Esto nos permitir√° combinar capacidades y hacer el uso m√°s din√°mico de los plugins.

Haremos la prueba con un simple endpoint que invoque el prompt

```csharp
app.MapPost("/api/chat", async (ChatRequest request, Kernel kernel) =>
{
    var settings = new OpenAIPromptExecutionSettings()
    {
        FunctionChoiceBehavior = FunctionChoiceBehavior.Auto()
    };

	// Aqu√≠ podr√≠amos hacer un Prompt m√°s expl√≠cito para el modelo si nuestra intenci√≥n fuera
	// solo contestar preguntas sobre el clima.

    var response = await kernel.InvokePromptAsync(request.Question, new(settings));

    return Results.Ok(new
    {
        Result = response.ToString()
    });
});
```

#### **Explicaci√≥n del C√≥digo**

1. **Uso del Kernel**:
    - El m√©todo `InvokePromptAsync` utiliza el kernel para procesar el prompt y determinar qu√© funci√≥n de los plugins debe ejecutarse.
    - En este caso, el Kernel autom√°ticamente seleccionar√° el m√©todo correcto (`GetCurrentUtcTime` o `GetWeatherByCity`) basado en el texto del prompt.
2. **Integraci√≥n Flexible**:
    - La estructura permite enviar cualquier pregunta o texto, dejando que el Kernel interprete y seleccione el m√©todo adecuado.
	    - Tambi√©n podemos hacer prompts donde seamos expl√≠citos de que Plugin queremos que el modelo utilice, pero por ahora lo dejamos en autom√°tico y que el modelo decida.


### **4. Probar los Endpoints**

Con los endpoints configurados y los plugins integrados en el **Kernel**, es momento de validarlos y observar c√≥mo funcionan.

#### **Ejemplo 1: Consultar el Clima**

Utilizando **Postman**, env√≠a la siguiente solicitud al endpoint configurado:

```json
{
¬† "question": "Cu√°l es el clima actual en Londres"
}
```

Al depurar la aplicaci√≥n, notar√°s que el modelo entiende la intenci√≥n del prompt, lo asocia con nuestro plugin y determina que queremos el clima actual de Londres. Esto sucede porque hemos registrado una funci√≥n espec√≠fica que devuelve esta informaci√≥n:

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/b1omsz3jsf1r2gqu742m.png)

La respuesta ser√≠a algo similar a:

```json
{
¬† ¬† "result": "El clima actual en Londres es fr√≠o y nublado, con una temperatura de 8.6¬∞C y un viento que sopla a 6.8 km/h. La codificaci√≥n del tiempo es 3, lo que indica condiciones clim√°ticas mezcladas, con algunas nubes y posibles lluvias."
}
```

#### **Ejemplo 2: Consultar Informaci√≥n de una Ciudad**

Ahora, realiza una consulta diferente, como esta:

```json
{
¬† "question": "Cu√°l es la poblaci√≥n actual de Madrid?"
}
```

En este caso, el modelo invocar√° autom√°ticamente otra funci√≥n registrada en el plugin que se encarga de obtener informaci√≥n sobre una ciudad:

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7pf76oqlglt0322h9whj.png)

La respuesta ser√° algo como:

```json
{
¬† ¬† "result": "La poblaci√≥n actual de Madrid es de aproximadamente 3,255,594 personas, seg√∫n la informaci√≥n proporcionada por el servicio de informaci√≥n geogr√°fica."
}
```

¬øNotas el poder detr√°s de esta integraci√≥n? Con esta configuraci√≥n, el **Kernel** puede realizar tareas que antes requer√≠an m√∫ltiples servicios separados. Todo se reduce a c√≥mo estructuramos los prompts y las funciones de nuestros plugins.

¬°Y esto es solo el principio! A√∫n no hemos explorado caracter√≠sticas avanzadas como **memoria sem√°ntica** y **RAG (Retrieval-Augmented Generation)**, pero con lo que ya tenemos, podemos construir soluciones extremadamente flexibles y personalizadas para cualquier dominio o industria.

Con prompts m√°s espec√≠ficos, puedes resolver problemas complejos y automatizar procesos avanzados. La √∫nica limitaci√≥n es tu creatividad y las necesidades de tu proyecto.

### **5. Extender Funcionalidades y Consideraciones Finales**

Ahora que hemos visto c√≥mo registrar plugins y probarlos con el **Kernel**, reflexionemos sobre c√≥mo podemos extender estas funcionalidades para adaptarlas a necesidades m√°s complejas. Aqu√≠ algunas ideas y recomendaciones para el siguiente nivel:

#### **Incorporar M√°s Plugins**

La flexibilidad de **Semantic Kernel** nos permite agregar m√°s funciones a nuestros plugins o crear nuevos plugins para cubrir otras √°reas de inter√©s, como:

- **An√°lisis de texto:** Procesar grandes vol√∫menes de datos textuales para obtener res√∫menes, extraer palabras clave o identificar entidades.
- **Integraciones externas:** Conectar con APIs de terceros para realizar tareas como manejo de correos electr√≥nicos, acceso a sistemas empresariales o realizar transacciones.
- **Procesamiento de im√°genes:** Usar servicios como OCR para reconocer texto en im√°genes o realizar an√°lisis visual.

#### **Usar Memoria Sem√°ntica**

La **memoria sem√°ntica** de Semantic Kernel puede almacenar y recuperar informaci√≥n contextualmente relevante. Por ejemplo:

- Recordar interacciones previas para mejorar la experiencia del usuario.
- Contextualizar consultas complejas bas√°ndose en datos hist√≥ricos.
- Implementar personalizaci√≥n profunda en aplicaciones que requieran un historial de acciones o preferencias.

#### **Optimizaci√≥n de Prompts**

Un dise√±o adecuado de prompts es clave para mejorar la precisi√≥n de los resultados. Algunas recomendaciones:

- **Sea espec√≠fico:** Prompts detallados producen resultados m√°s enfocados.
- **Use ejemplos:** Proporcionar ejemplos en el prompt puede ayudar al modelo a entender la intenci√≥n de manera m√°s clara.
- **Eval√∫e y ajuste:** Experimente con diferentes configuraciones para obtener mejores resultados en diferentes escenarios.

#### **Escalabilidad y Producci√≥n**

Si bien en estos ejemplos usamos **Ollama** localmente para evitar problemas de infraestructura, en un entorno de producci√≥n puedes cambiar sin modificar tu c√≥digo base y usar servicios como **OpenAI** o **Azure OpenAI** para aprovechar su escalabilidad y confiabilidad. Esto implica:

- Definir claves API para entornos seguros.
- Configurar pol√≠ticas de acceso seg√∫n las necesidades de tu organizaci√≥n.
- Monitorear el uso y los costos para optimizar el rendimiento.

#### **Casos de Uso Empresariales**

Con los elementos ya implementados, podemos visualizar algunos casos pr√°cticos donde estas capacidades sean √∫tiles:

- **Asistentes de soporte:** Resolver consultas comunes en tiempo real con informaci√≥n siempre actualizada.
- **Automatizaci√≥n de tareas repetitivas:** Por ejemplo, generar reportes basados en datos o notificaciones programadas.
- **Sistemas personalizados:** Aplicaciones inteligentes que se adapten din√°micamente a las necesidades de los usuarios, como dashboards interactivos o chatbots avanzados.
### **Conclusi√≥n**

Con **Semantic Kernel**, hemos transformado lo que tradicionalmente ser√≠a una combinaci√≥n de servicios aislados en una soluci√≥n unificada y potente. Desde entender intenciones en lenguaje natural hasta ejecutar acciones basadas en plugins espec√≠ficos, el Kernel nos proporciona una plataforma flexible y extensible para la creaci√≥n de aplicaciones inteligentes.

La verdadera ventaja de esta tecnolog√≠a radica en su capacidad de evoluci√≥n. Puedes comenzar con casos de uso simples, como los ejemplos de este tutorial, y escalar hacia soluciones m√°s complejas que integren m√∫ltiples fuentes de datos, memoria sem√°ntica y funcionalidades avanzadas.

Tu creatividad y las necesidades de tu proyecto dictar√°n el camino. Ahora que tienes las bases, ¬øqu√© construir√°s con **Semantic Kernel**?